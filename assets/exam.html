<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Exam Portal â€” Full FaceMesh with Eye Bubble</title>

  <!-- Firebase + App Initialization FIRST -->
  <script type="module">
    window.isPageReload = performance.getEntriesByType("navigation")[0].type === "reload";
    window.isReloadSession = false;
    window.skipIncompleteOnNextUnload = false;
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { deleteField } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { onSnapshot } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    const firebaseConfig = {
      apiKey: 'AIzaSyD3QA26qrdwXjt1eRn_OBqX0zw8kbiyV3o',
      appId: '1:348602182315:web:e5b92040815a2ef94665ee',
      messagingSenderId: '348602182315',
      projectId: 'rd-final',
      authDomain: 'rd-final.firebaseapp.com',
      databaseURL: 'https://rd-final-default-rtdb.asia-southeast1.firebasedatabase.app',
      storageBucket: 'rd-final.firebasestorage.app',
      measurementId: 'G-WBN9RY3QKG'
    };
    window.firestoreDoc = doc;
    window.firestoreCollection = collection;

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    window.answers = {};
    window.db = db; // make db global so your exam code can access it
    window.strikes = window.strikes ?? 0;
    window.examFinished = window.examFinished ?? false;
    window.cheatingCount = window.cheatingCount ?? 0;
    let studentId;
    let answers = {};
    // Flag to track if DOMContentLoaded ran
    window.domReady = false;
    window.hasSubmitted = window.hasSubmitted || false;
    // Listen for Flutter injection
    window.addEventListener("message", (event) => {
      const { examId, studentId } = event.data || {};
      if (examId && studentId) {
        window.examData = { examId, studentId, answers: {} };

        // If DOM is already ready, continue exam flow
        if (window.domReady) {
          restoreOrStartExam();
        }
      }
    });

    // Listen for DOM ready
    window.addEventListener("DOMContentLoaded", () => {
      window.domReady = true;

      // If examData is already injected, continue exam flow
      if (window.examData?.examId && window.examData?.studentId) {
        restoreOrStartExam();
      }
    });
    function listenForStatusChanges(examId, studentId) {
      const resultRef = doc(db, "examResults", examId, "students", studentId);

      onSnapshot(resultRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();
        const currentIndex = data.currentIndex;

        if (currentIndex === "stopped" && !window.hasSubmitted) {
          const interval = setInterval(async () => {
            if (window.examReady && !window.hasSubmitted) {
              clearInterval(interval);
              window.hasSubmitted = true;
              await setDoc(
                resultRef,
                {
                  status: "incomplete",
                },
                { merge: true }
              );
              alert("The exam has been stopped.");
              window.submitExam(true);
            }
          }, 50);

          // Safety timeout to clear interval anyway
          setTimeout(() => clearInterval(interval), 10000);
        }
      });
    }


    // Shared function
    async function restoreOrStartExam() {
      const { examId, studentId } = window.examData;
      const wasUnloading = sessionStorage.getItem("is_unloading");
      listenForStatusChanges(examId, studentId);

      if (wasUnloading) {
        window.isReloadSession = true;
        sessionStorage.removeItem("is_unloading");

        const resultRef = doc(
          window.db,
          "examResults",
          examId,
          "students",
          studentId
        );
        await setDoc(resultRef, { status: "in-progress" }, { merge: true });
      } else {
        window.isReloadSession = false;
      }

      const wasStarted = sessionStorage.getItem("examStarted") === "1";
      if (wasStarted) {
        window.examStarted = true;
        window.allowStrikes = true;
        document.getElementById("examGate").style.display = "none";
        document.getElementById("examCard").style.display = "block";
      } else {
        window.examStarted = false;
        window.allowStrikes = false;
        document.getElementById("examGate").style.display = "block";
        document.getElementById("examCard").style.display = "none";
      }

      // Kick off exam flow if fresh
      markInProgress();
      startCountdownFromFirestore(examId);
      await loadExamQuestions(examId);
      window.strikesLoadedPromise = loadExistingStrikes();
      await window.strikesLoadedPromise;
      window.examReady = true;
      setTimeout(() => {
        window.isReloadSession = false;
        //loadExistingStrikes();
      }, 50);
    }

    const urlParams = new URLSearchParams(window.location.search);
    const examId = urlParams.get("examId");
    history.replaceState({}, "", examId ? `?examId=${encodeURIComponent(examId)}` : window.location.pathname);
    window.logCheatingEvent = async function logCheatingEvent() {
      if (window.examFinished) return;
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(
          db,
          "examResults",
          examId,
          "students",
          studentId
        );
        const snap = await getDoc(resultRef);
        const currentStatus = snap.exists() ? snap.data().status : null;
        if (currentStatus === "completed" || currentStatus === "incomplete") return;

        await setDoc(resultRef, {
          examId,
          studentId,
          status: currentStatus ?? "in-progress",
          lastCheatingUpdate: new Date(),
          cheatingCount: (snap.exists() && snap.data().cheatingCount ? snap.data().cheatingCount + 1 : 1)
        }, { merge: true });

        window.cheatingCount++;
      } catch (err) {
        console.error("logCheatingEvent error:", err);
      }
    };
    async function markInProgress() {
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(window.db, "examResults", examId, "students", studentId);
        const snap = await getDoc(resultRef);

        if (snap.exists()) {
          const status = snap.data().status;
          if (status === "completed" || status === "incomplete") {
            // Already finished â€” redirect to result page
            window.parent.postMessage({
              action: 'finishExam',
              examId: examId,
              //studentId: studentId
            }, "*");
            return;
          }
        }

        // Otherwise mark in-progress
        await setDoc(resultRef, {
          status: "in-progress",
          startedAt: new Date()
        }, { merge: true });

      } catch (err) {
        console.error("markInProgress error:", err);
      }
    }



    // Single canonical strike register
    window.registerStrikeOnce = (function () {
      let lastAway = 0;
      return async function registerStrikeOnce() {
        if (window.strikesLoadedPromise) await window.strikesLoadedPromise;
        const now = Date.now();
        if (now - lastAway < 1200) return;
        lastAway = now;

        window.strikes = (window.strikes || 0) + 1;

        document.getElementById("strikeBox").textContent = `Strikes: ${window.strikes}`;

        // Always log local
        window.logCheatingEvent();

        // Push increment to Firestore (never decreases)
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        pushStrikeToFirestore(examId, studentId);

        console.log("Strike registered:", window.strikes);
        sendToArduino("STRIKE");
      };
    })();
    async function pushStrikeToFirestore(examId, studentId) {
      const resultRef = doc(window.db, "examResults", examId, "students", studentId);

      await setDoc(resultRef, {
        cheatingCount: increment(1)
      }, { merge: true });
    }

    // Mark incomplete (keep this in module so beforeunload can call it safely)
    window.markIncompleteIfNeeded = function () {
      try {
        if (window.examFinished) return;
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(window.db, "examResults", examId, "students", studentId);
        setDoc(resultRef, {
          status: "incomplete",
          submittedAt: new Date()
        }, { merge: true });
      } catch (err) {
        console.error("markIncomplete error:", err);
      }
    };


    window.saveAnswerToFirestore = async function (q, val, displayIndex) {
      const examId = window.examData?.examId;
      const studentId = window.examData?.studentId;
      if (!examId || !studentId) return false;

      const studentDoc = doc(window.db, "examResults", examId, "students", studentId);
      const answerRef = doc(collection(studentDoc, "answers"), q.id);

      let answerValue = val;
      if (q.type?.toLowerCase() === "checkbox") {
        // collect all checked boxes for this question
        const inputs = document.querySelectorAll(`input[name="${q.id}"]:checked`);
        answerValue = Array.from(inputs).map(i => i.value);
      }

      try {
        await setDoc(answerRef, {
          questionId: q.id,
          question: q.questionText,
          answer: answerValue,
          //correctAnswer: q.correctAnswer,
          displayIndex
        }, { merge: true });
        window.answers[q.id] = answerValue;
        return true;
      } catch (err) {
        console.error("Firestore save failed:", err);
        return false;
      }
    };

    window.submitExam = async function submitExam(forceIncomplete = false) {
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) {
          console.error("Missing examId or studentId");
          return;
        }

        //Fetch all saved answers from Firestore
        const studentDoc = doc(window.db, "examResults", examId, "students", studentId);

        const answersCol = collection(studentDoc, "answers");
        const answersSnap = await getDocs(answersCol);

        const savedAnswers = {};
        answersSnap.forEach(docSnap => {
          const data = docSnap.data();
          savedAnswers[data.questionId] = data.answer;
        });

        //Compute score using saved answers + correctAnswer from window.questions
        let computedScore = 0;

        for (let i = 0; i < window.questions.length; i++) {
          const q = window.questions[i];
          const ans = savedAnswers[q.id];
          const correct = q.correctAnswer;

          if (ans && correct) {
            if (ans.toString().toLowerCase() === correct.toString().toLowerCase()) {
              computedScore++;
            }
          }
        }
        //Get subject from exam doc
        let subject = "";
        try {
          const examDoc = await getDoc(doc(window.db, "exams", examId));
          if (examDoc.exists()) {
            subject = examDoc.data().subject || "";
          }
        } catch (err) {
          console.warn("Could not fetch subject:", err);
        }

        // Write result to Firestore
        await setDoc(studentDoc, {
          status: forceIncomplete ? "incomplete" : "completed",
          score: computedScore,
          total: window.questions.length,
          submittedAt: serverTimestamp(),
          currentIndex: forceIncomplete ? "stopped" : "finished",
        }, { merge: true });


        // Redirect to result page
        window.parent.postMessage({
          action: 'finishExam',
          examId: examId,
          //studentId: studentId
        }, "*");
        // Mark exam finished
        window.examFinished = true;
        window.questions = [];
        window.answers = {};
        window.examData = null;
        window.cheatingCount = 0;
        window.strikes = 0;
        sessionStorage.clear();
        // Stop camera if running
        try { camera?.stop?.(); } catch (_) { }
      } catch (err) {
        console.error(" submitExam error:", err.message, err);
      }
    };
    async function startCountdownFromFirestore(examId) {

      const examRef = doc(db, "exams", examId);   
      const examSnap = await getDoc(examRef);

      if (!examSnap.exists()) {
        console.error(" Exam not found for examId:", examId);
        countdownEl.textContent = "Exam not found!";
        return;
      }

      const data = examSnap.data();

      const endTime = data.endTime?.toDate?.().getTime?.();
      const startTime = data.startTime?.toDate?.().getTime?.();

      if (!endTime || !startTime) {
        console.error(" Missing start/end time in exam doc:", data);
        countdownEl.textContent = "No schedule set";
        return;
      }

      const timer = setInterval(() => {
        const durationMs = endTime - startTime;
        const elapsedMs = Date.now() - startTime;
        const remainingMs = Math.max(durationMs - elapsedMs, 0);
        if (remainingMs <= 0) {
          clearInterval(timer);
          countdownEl.textContent = "Time's up!";
          window.markIncompleteIfNeeded();
          window.parent.postMessage({
            action: 'finishExam',
            examId: examId,
            //studentId: studentId
          }, "*");
          return;
        }
        countdownEl.textContent = "Time Left: " + formatRemaining(remainingMs);
      }, 1000);
    }


    // Visibility change  log strike if not reload/shell
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        setTimeout(() => {
          if (document.hidden && !window.skipIncompleteOnNextUnload) {
            window.registerStrikeOnce();
          }
        }, 1200); 
      }
    });
    //Detect window shrink on mobile + iframe + Flutter
    const MIN_WIDTH = 600;  
    const MIN_HEIGHT = 450;

    new ResizeObserver(() => {
      const vw = document.documentElement.clientWidth;
      const vh = document.documentElement.clientHeight;

      if ((vw < MIN_WIDTH || vh < MIN_HEIGHT) && !window.skipIncompleteOnNextUnload) {
        window.registerStrikeOnce();
      }
    }).observe(document.documentElement);

    //detect iframe/body being resized by Flutter shell
    new ResizeObserver(() => {
      const rect = document.body.getBoundingClientRect();

      if ((rect.width < MIN_WIDTH || rect.height < MIN_HEIGHT) && !window.skipIncompleteOnNextUnload) {
        window.registerStrikeOnce();
      }
    }).observe(document.body);
    // Detect parent-shell losing visibility
    window.addEventListener("message", (event) => {
      if (!event.data) return;

      // if (event.data.action === "shell-blur") {
      //   if (!window.skipIncompleteOnNextUnload) {
      //     console.log("parent window blur (app switch/minimize) â€” strike");
      //     window.registerStrikeOnce();
      //   }
      // }

      if (event.data.action === "shell-focus") {
        console.log("Shell refocused");
      }
    });
    window.addEventListener("beforeunload", () => {

      sessionStorage.setItem("is_unloading", "true");

      if (window.examStarted) {
        sessionStorage.setItem("examStarted", "1");
      }

      if (window.isPageReload || window.skipIncompleteOnNextUnload) {
        return;
      }

      window.markIncompleteIfNeeded();
    });
    window.addEventListener("pagehide", (event) => {
      if (event.persisted) return;

      sessionStorage.setItem("is_unloading", "true");

      if (window.examStarted) {
        sessionStorage.setItem("examStarted", "1");
      }

      if (window.isPageReload || window.skipIncompleteOnNextUnload) {
        return;
      }

      window.markIncompleteIfNeeded();
    });

    let currentQuestionIndex = 0;
    function isQuestionAnswered(q) {
      const type = q.type?.toLowerCase();

      //Multiple Choice / True-False
      if (type === "multiple-choice" || type === "true-false") {
        const el = document.querySelector(`input[name="${q.id}"]:checked`);
        if (!el) return null;
        return el.value;
      }

      //Matching / Dropdown
      if (type === "matching" || type === "dropdown") {
        const sel = document.querySelector(`select[name="${q.id}"]`);
        if (!sel || sel.value.trim() === "") return null;
        return sel.value;
      }

      //Multiple answers
      if (type === "checkbox") {
        const inputs = document.querySelectorAll(`input[name="${q.id}"]:checked`);
        const values = Array.from(inputs).map(i => i.value);
        return values.length > 0 ? values : null;
      }

      return null;
    }

    function getSelectedAnswer(q) {
      return isQuestionAnswered(q);
    }

    window.handleAnswerChange = async function (index) {
      const q = window.questions[index];
      if (!q) return;

      const val = getSelectedAnswer(q);
      const btn = document.getElementById("nextQuestion");
      if (btn) btn.disabled = !val;

      if (!val) return;

      await window.saveAnswerToFirestore(q, val, index);
    };
    function showQuestion(index) {
      const q = window.questions?.[index];
      if (!q) return;

      try {
        document.getElementById('examContent').innerHTML =
          generateQuestionHtml(q, index, window.answers, window.matchingPool || []);
      } catch (err) {
        console.error("generateQuestionHtml failed:", err);
        document.getElementById('examContent').innerHTML = `
      <h2>Question ${index + 1}</h2>
      <div class="question"><p>${q.questionText ?? "No text"}</p></div>
    `;
      }

      const btn = document.getElementById("nextQuestion");
      if (!btn) return;
      btn.disabled = !isQuestionAnswered(q);

      // Listen to changes (ensure button state)
      const inputs = document.querySelectorAll(`input[name="${q.id}"], select[name="${q.id}"]`);
      inputs.forEach(inp => {
        inp.addEventListener("change", () => {
          btn.disabled = !isQuestionAnswered(q);
        });
      });

      renderNextOrSubmitButton();
    }
    function renderNextOrSubmitButton() {
      const btn = document.getElementById("nextQuestion");
      if (!btn) return;
      const q = window.questions[currentQuestionIndex];

      btn.disabled = false;

      if (currentQuestionIndex < window.questions.length - 1) {
        btn.textContent = "Next";
        btn.onclick = async () => {
          if (!isQuestionAnswered(q)) return;

          btn.disabled = true;
          btn.textContent = "Saving...";

          const val = getSelectedAnswer(q);
          const saved = await window.saveAnswerToFirestore(q, val, currentQuestionIndex);
          if (!saved) {
            alert("Saving failed. Check your internet and try again.");
            btn.disabled = false;
            btn.textContent = "Next";
            return;
          }

          try {
            const examId = window.examData.examId;
            const studentId = window.examData.studentId;
            const studentCollection = doc(window.db, "examResults", examId, "students", studentId);

            await setDoc(studentCollection, { currentIndex: currentQuestionIndex + 1 }, { merge: true });
          } catch (err) {
            console.error("Failed to save currentIndex:", err);
          }

          currentQuestionIndex++;
          showQuestion(currentQuestionIndex);
        };
      }
      // Submit button (last question)
      else {
        btn.textContent = "Submit";
        btn.onclick = async () => {
          if (!isQuestionAnswered(q)) return;

          btn.disabled = true;
          btn.textContent = "Saving...";

          const val = getSelectedAnswer(q);
          const saved = await window.saveAnswerToFirestore(q, val, currentQuestionIndex);
          if (!saved) {
            alert("Saving failed. Check your internet.");
            btn.disabled = false;
            btn.textContent = "Submit";
            return;
          }

          window.submitExam();
        };
      }
    }


    async function loadExamQuestions(examId) {
      if (!examId) {
        console.error("loadExamQuestions called with null examId");
        return;
      }

      // Reset UI placeholders
      document.getElementById('examContent').innerHTML = `
    <h2>Loadingâ€¦</h2>
    <div class="question"><p>Loadingâ€¦</p></div>
  `;

      try {

        //Fetch all question docs
        const questionsCol = collection(db, "exams", examId, "questions");
        const snapshot = await getDocs(questionsCol);

        if (snapshot.empty) {
          console.error("No questions found in Firestore for exam:", examId);
          document.getElementById('examContent').innerHTML = "<p>No questions found.</p>";
          return;
        }

        const rawQuestions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        const groups = {
          "true-false": [],
          "multiple-choice": [],
          "matching": []
        };

        // Put each question into its group
        rawQuestions.forEach(q => {
          const t = (q.type || "").toLowerCase();
          if (groups[t]) groups[t].push(q);
        });

        // Shuffle each group independently
        Object.keys(groups).forEach(type => {
          groups[type] = shuffleArray(groups[type]);
        });

        // Build final grouped+random order
        const sortedRandom = [
          ...groups["true-false"],
          ...groups["multiple-choice"],
          ...groups["matching"]
        ];

        const finalQuestions = sortedRandom;

        const resultRef = doc(db, "examResults", examId, "students", window.examData.studentId);
        const resultSnap = await getDoc(resultRef);

        let orderedIds;
        if (resultSnap.exists() && resultSnap.data().questionOrder) {
          orderedIds = resultSnap.data().questionOrder;
        } else {
          orderedIds = finalQuestions.map(q => q.id);
          await setDoc(resultRef, { questionOrder: orderedIds }, { merge: true });
        }
        const orderedQuestions = orderedIds.map((qid, idx) => {
          const q = rawQuestions.find(rq => rq.id === qid);
          if (!q) {
            console.warn("Question ID not found:", qid);
            return null;
          }
          return {
            ...q,
            index: idx,
            questionText: q.questionText ?? q.text ?? "",
            type: (q.type ?? q.kind ?? "multiple-choice").toLowerCase(),
            options: Array.isArray(q.options) ? q.options : (Array.isArray(q.choices) ? q.choices : [])
          };
        }).filter(Boolean);

        window.questions = orderedQuestions;
        window.answers = window.answers || {};

        //Build matching pool now that window.questions exists
        window.matchingPool = Array.from(new Set(
          window.questions
            .filter(q => q.type === 'matching' && Array.isArray(q.options))
            .flatMap(q => q.options)
        ));

        if (resultSnap.exists() && resultSnap.data().currentIndex !== undefined) {
          currentQuestionIndex = resultSnap.data().currentIndex;
          console.log("Restored currentIndex:", currentQuestionIndex);
        } else {
          console.log("â„¹No currentIndex saved, starting at 0");
        }

        try {
          showQuestion(currentQuestionIndex);
          renderNextOrSubmitButton();
        } catch (err) {
          console.error("showQuestion/render failed:", err);
          document.getElementById('examContent').innerHTML = `<p>Error rendering question: ${err.message}</p>`;
        }

      } catch (err) {
        console.error("loadExamQuestions failed:", err);
        document.getElementById('examContent').innerHTML = `<p>Error loading questions: ${err.message}</p>`;
      }
    }
    window.strikesLoadedPromise = null;

    async function loadExistingStrikes() {
      const examId = window.examData?.examId;
      const studentId = window.examData?.studentId;
      if (!examId || !studentId) return;

      const resultRef = doc(window.db, "examResults", examId, "students", studentId);
      const snap = await getDoc(resultRef);

      if (snap.exists()) {
        const saved = snap.data().cheatingCount;
        if (typeof saved === "number") {
          // never lower local strikes
          window.strikes = Math.max(window.strikes || 0, saved);
        }
      }

      // If Firestore is offline or empty â†’ keep local value
      window.cheatingCount = window.strikes;
      document.getElementById("strikeBox").textContent = `Strikes: ${window.strikes}`;
    }




  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --navy: #0f2b45;
      --card: #0f3b61;
      --accent: #1e90ff;
      --bg: #0b1220;
      --ok: #2ecc71;
      --warn: #ff6b6b;
      --muted: #b7c7d6;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg, #061225 0%, #071728 100%);
      color: #e6f0f8;
      -webkit-font-smoothing: antialiased;
      position: relative;
      min-height: 100vh;
    }

    .topbar {
      height: 64px;
      background: var(--navy);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, .4);
    }

    .topbar .brand {
      font-weight: 700;
      letter-spacing: 0.6px
    }

    .topbar .timer {
      font-size: 14px;
      color: var(--muted)
    }

    .wrap {
      max-width: 1100px;
      margin: 28px auto;
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 20px;
      padding: 0 16px;
    }

    .card {
      background: #0b2a44;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .4);
      position: relative;
      overflow: visible;
    }

    #examGate,
    #examCard {
      min-height: 500px;
    }

    .card h2 {
      margin: 0 0 14px;
      font-size: 18px;
      color: #f3fbff
    }

    .question {
      background: #071a2b;
      border-radius: 8px;
      padding: 14px;
      color: #dbeefc;
      margin-bottom: 18px;
    }

    .options label {
      display: block;
      padding: 8px 12px;
      margin: 8px 0;
      border-radius: 6px;
      cursor: pointer;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.03);
    }

    .options input {
      margin-right: 10px
    }

    .btn {
      background: var(--accent);
      color: #06203a;
      border: none;
      padding: 10px 18px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(30, 144, 255, .16);
    }

    select {
      width: 100%;
      padding: 10px 12px;
      background: #071a2b;
      color: #e6f0f8;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 6px;
      font-size: 15px;
      margin-top: 8px;
      margin-bottom: 8px;
      appearance: none;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      transition: border-color 0.2s, background-color 0.2s;
    }

    select:focus {
      outline: none;
      border-color: #1e90ff;
      background: #0b2a44;
    }

    /* Dropdown options */
    select option {
      background: #071a2b;
      color: #e6f0f8;
    }


    .card::after {
      content: "";
      position: absolute;
      inset: 6px;
      border: 3px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      pointer-events: none;
      transition: border-color 0.18s, box-shadow 0.18s;
    }

    .card.alert::after {
      border-color: var(--warn);
      box-shadow: 0 0 30px rgba(255, 107, 107, 0.12);
    }

    .camera-panel {
      background: #071a2b;
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .45);
    }

    .cam-viewport {
      position: relative;
      width: 100%;
      aspect-ratio: 4/5;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }

    video#input_video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    canvas#overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      transform: scaleX(-1);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
    }

    .face-status {
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(0, 0, 0, 0.15);
      color: var(--muted);
    }

    .face-status.ok {
      background: rgba(46, 204, 113, 0.12);
      color: var(--ok);
      border: 1px solid rgba(46, 204, 113, 0.18)
    }

    .face-status.bad {
      background: rgba(255, 107, 107, 0.08);
      color: var(--warn);
      border: 1px solid rgba(255, 107, 107, 0.12)
    }

    .recording {
      font-size: 13px;
      color: var(--muted)
    }

    .verified-line {
      font-weight: 600;
      font-size: 15px
    }

    .gaze-bubble {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(30, 144, 255, 0.95);
      box-shadow: 0 6px 14px rgba(30, 144, 255, 0.2);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 9999;
      transition: box-shadow 0.12s;
    }

    .gaze-bubble.alert {
      background: rgba(255, 107, 107, 0.95);
      box-shadow: 0 8px 20px rgba(255, 107, 107, 0.25);
    }

    .strike-indicator {
      position: absolute;
      right: 14px;
      top: 14px;
      font-size: 13px;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.12);
      padding: 6px 8px;
      border-radius: 8px;
    }

    .score-box {
      margin-top: 12px;
      font-weight: 600;
      font-size: 15px;
      color: var(--accent);
    }

    @media (max-width:900px) {
      .wrap {
        grid-template-columns: 1fr;
      }

      .camera-panel {
        order: 2;
      }

      #examContent {
        min-height: 380px;
      }

    }
  </style>
</head>

<body>

  <div class="topbar">
    <div class="brand">EXAM PORTAL</div>
    <div class="timer" id="countdown">Time Left: 00:00</div>
    <button id="connectBtn" class="btn">ðŸ”Œ Connect Arduino</button>
  </div>


  <div class="wrap">

    <!-- shared strike indicator (single id) -->
    <div style="position:relative;">
      <div class="strike-indicator" id="strikeBox" style="position:absolute; right:14px; top:-8px; z-index:20;">
        Strikes: 0
      </div>

      <!-- GATE CARD (visible first) -->
      <div class="card" id="examGate">
        <div id="examContentGate">
          <h2 style="text-align:center;">Face verification required</h2>
          <p style="text-align:center;">Please look at the screen to start your exam.</p>

          <div style="display:flex; justify-content:center; margin-top:12px;">
            <img src="image/fots_student.png" style="width:180px; border-radius:8px;">
          </div>
        </div>
      </div>

      <!-- EXAM CARD (hidden first) -->
      <div class="card" id="examCard" style="display:none;">
        <div id="examContent">
          <h2>Question 1</h2>
          <div class="question">
            <p>Loading questions...</p>
          </div>
        </div>

        <div style="margin-top:12px; text-align:right;">
          <button class="btn" id="nextQuestion">Next</button>
        </div>
      </div>
    </div>




    <!-- RIGHT SIDE â€” CAMERA PANEL (NOW SEPARATE) -->
    <div class="camera-panel">
      <div class="cam-viewport">
        <video id="input_video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="status-row">
        <div id="faceStatus" class="face-status bad">
          <span id="faceIcon">â›”</span>
          <div>
            <div class="verified-line" id="faceText">Face not verified</div>
            <div style="font-size:12px; color:var(--muted)">
              Please center your face in the box and keep eyes on the screen
            </div>
          </div>
        </div>

        <div style="text-align:right">
          <div class="recording" id="recLabel">Recording. Active</div>
        </div>
      </div>
    </div>

  </div>

  <!-- Gaze bubble must stay OUTSIDE wrap -->
  <div id="gazeBubble" class="gaze-bubble" style="left:50%; top:50%; display:block;"></div>


  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    //ARDUINO SERIAL CONNECTION
    let port;
    let writer;

    document.getElementById('connectBtn').addEventListener('click', async () => {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        const textEncoder = new TextEncoderStream();
        const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
        writer = textEncoder.writable.getWriter();
        alert("Connected to Arduino!");
      } catch (err) {
        alert("Connection failed: " + err);
      }
    });

    async function sendToArduino(message) {
      if (!writer) return;
      await writer.write(message + "\n");
      console.log("Sent to Arduino:", message);
    }
    // ===============================================


    // ========== EXISTING EXAM CODE (UNCHANGED) ==========
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('overlay');
    const canvasCtx = canvasElement.getContext('2d');
    const faceStatus = document.getElementById('faceStatus');
    const faceText = document.getElementById('faceText');
    const faceIcon = document.getElementById('faceIcon');
    const countdownEl = document.getElementById('countdown');
    const submitBtn = document.getElementById('submitBtn');
    const examCard = document.getElementById('examCard');
    const gazeBubble = document.getElementById('gazeBubble');
    const strikeBox = document.getElementById('strikeBox');

    let totalSeconds = 60 * 60;
    window.allowStrikes = false;

    function formatRemaining(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const hours = Math.floor(totalSec / 3600);
      const minutes = Math.floor((totalSec % 3600) / 60);
      const seconds = totalSec % 60;
      if (hours > 0) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.55,
      minTrackingConfidence: 0.55
    });

    let verified = false;
    let lastVerifiedChange = Date.now();
    const STABLE_MS = 300;
    let strikes = 0;
    let blocked = false;

    let bubbleX = window.innerWidth / 2, bubbleY = window.innerHeight / 2;
    let targetX = bubbleX, targetY = bubbleY;
    const SENSITIVITY = 10.4;

    function onResults(results) {
      const vw = videoElement.clientWidth;
      const vh = videoElement.clientHeight;
      canvasElement.width = vw; canvasElement.height = vh;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        setVerification(false, "Face not found");
        targetX = window.innerWidth / 2; targetY = window.innerHeight / 2;
        updateBubble(); return;
      }

      const lm = results.multiFaceLandmarks[0];
      const leftIris = lm[468];
      const rightIris = lm[473];
      const leftEyeFallback = lm[159];
      const rightEyeFallback = lm[386];

      let irisXNorm, irisYNorm;
      if (leftIris && rightIris) { irisXNorm = (leftIris.x + rightIris.x) / 2; irisYNorm = (leftIris.y + rightIris.y) / 2; }
      else if (leftIris) { irisXNorm = leftIris.x; irisYNorm = leftIris.y; }
      else if (rightIris) { irisXNorm = rightIris.x; irisYNorm = rightIris.y; }
      else { irisXNorm = (leftEyeFallback.x + rightEyeFallback.x) / 2; irisYNorm = (leftEyeFallback.y + rightEyeFallback.y) / 2; }

      const irisXVideo = (1 - irisXNorm) * vw;
      const irisYVideo = irisYNorm * vh;

      canvasCtx.beginPath();
      canvasCtx.fillStyle = 'rgba(30,144,255,0.95)';
      canvasCtx.arc(irisXVideo, irisYVideo, 5, 0, Math.PI * 2);
      canvasCtx.fill();

      const offsetX = (irisXVideo - vw / 2) / vw;
      const offsetY = (irisYVideo - vh / 2) / vh;

      // choose the element that is currently visible (gate or exam)
      const targetEl = (window.examStarted ? document.getElementById('examCard') : document.getElementById('examGate'));
      const examRect = targetEl.getBoundingClientRect();
      if (examRect.width < 20 || examRect.height < 20) {
        return; // skip frame to prevent freeze
      }
      const examCx = examRect.left + examRect.width / 2;
      const examCy = examRect.top + examRect.height / 2;

      targetX = examCx + offsetX * examRect.width * SENSITIVITY;
      targetY = examCy + offsetY * examRect.height * SENSITIVITY;

      const pad = 8;
      targetX = Math.max(pad, Math.min(window.innerWidth - pad, targetX));
      targetY = Math.max(pad, Math.min(window.innerHeight - pad, targetY));

      const INSET_PCT = 0.06;
      const safeLeft = examRect.left + examRect.width * INSET_PCT;
      const safeRight = examRect.right - examRect.width * INSET_PCT;
      const safeTop = examRect.top + examRect.height * INSET_PCT;
      const safeBottom = examRect.bottom - examRect.height * INSET_PCT;

      const gazeOk = (targetX >= safeLeft && targetX <= safeRight && targetY >= safeTop && targetY <= safeBottom);

      if (!gazeOk) {
        examCard.classList.add('alert');
        gazeBubble.classList.add('alert');
        setVerification(false, "Looking away detected");
        if (window.allowStrikes) {
          registerStrikeOnce();
          sendToArduino("STRIKE");
        }
      } else {
        examCard.classList.remove('alert');
        gazeBubble.classList.remove('alert');
        setVerification(true, "Face & eyes centered");
        if (window.allowStrikes) {
          sendToArduino("OK");
        }
      }
      updateBubble();
    }


    function setVerification(ok, reason) {
      const now = Date.now();
      if (ok !== verified && (now - lastVerifiedChange) < STABLE_MS) return;
      if (ok !== verified) {
        verified = ok; lastVerifiedChange = now;
        if (verified) {
          faceStatus.classList.remove('bad');
          faceStatus.classList.add('ok');
          faceIcon.textContent = 'âœ”';
        }
        else {
          faceStatus.classList.remove('ok');
          faceStatus.classList.add('bad');
          faceIcon.textContent = 'âš ';
        }
      }
      faceText.textContent = reason || (verified ? "Face verified" : "Face not verified");
      if (verified && !window.examStarted) {

        window.examStarted = true;
        window.allowStrikes = true;
        sessionStorage.setItem("examStarted", "1");

        setTimeout(() => {
          document.getElementById("examGate").style.display = "none";
          document.getElementById("examCard").style.display = "block";

          loadExamQuestions(window.examData.examId);
          console.log("Face verified â†’ starting examâ€¦");
        }, 150);
        setTimeout(() => {
          strikeBox.textContent = `Strikes: ${window.strikes}`;
        }, 200);
      }
    }

    function updateBubble() {
      bubbleX += (targetX - bubbleX) * 0.18;
      bubbleY += (targetY - bubbleY) * 0.18;
      gazeBubble.style.left = `${bubbleX}px`;
      gazeBubble.style.top = `${bubbleY}px`;
    }

    function animLoop() { updateBubble(); requestAnimationFrame(animLoop); }
    animLoop();

    let camera = null;
    try {
      camera = new Camera(videoElement, { onFrame: async () => { await faceMesh.send({ image: videoElement }); }, width: 640, height: 800 });
      faceMesh.onResults(onResults);
      camera.start();
    } catch (err) {
      console.warn("Camera start failed:", err);
      faceText.textContent = "Camera unavailable â€” try localhost or allow camera access.";
      faceIcon.textContent = "âš ";
    }
    let matchingPool = [];
    let questions = [];

    function generateQuestionHtml(q, currentQuestionIndex, answers, matchingPool) {
      const selectedAnswer = answers?.[q.id] ?? null;
      const qType = (q.type || 'multiple-choice').toLowerCase();

      // Save helper
      const save = () => `onchange="handleAnswerChange(${currentQuestionIndex})"`;

      let html = `
    <h2>Question ${currentQuestionIndex + 1}</h2>
    <div class="question">
      <p>${q.questionText ?? ""}</p>
      <div class="options" data-qid="${q.id}" data-qtype="${qType}">
  `;

      //multiple-choice
      if (qType === 'multiple-choice') {
        (q.options ?? []).forEach(opt => {
          const checked = opt === selectedAnswer ? 'checked' : '';
          html += `
        <label>
          <input type="radio" name="${q.id}" value="${opt}" ${checked} ${save()}>
          ${opt}
        </label>`;
        });
      }

      //true-false
      else if (qType === 'true-false') {
        ['True', 'False'].forEach(opt => {
          const checked = opt === selectedAnswer ? 'checked' : '';
          html += `
        <label>
          <input type="radio" name="${q.id}" value="${opt}" ${checked} ${save()}>
          ${opt}
        </label>`;
        });
      }

      // checkbox
      else if (qType === 'checkbox') {
        (q.options ?? []).forEach(opt => {
          const checked = Array.isArray(selectedAnswer) && selectedAnswer.includes(opt) ? 'checked' : '';
          html += `
        <label>
          <input type="checkbox" name="${q.id}" value="${opt}" ${checked} ${save()}>
          ${opt}
        </label>`;
        });
      }

      //matching
      else if (qType === 'matching' || qType === 'dropdown') {
        const pool = Array.isArray(matchingPool) ? matchingPool : [];
        html += `<select name="${q.id}" data-qid="${q.id}" ${save()}>  
      <option value="">Select answer</option>
    `;
        pool.forEach(m => {
          const selected = m === selectedAnswer ? 'selected' : '';
          html += `<option value="${m}" ${selected}>${m}</option>`;
        });
        html += `</select>`;
      }

      //unsupported type
      else {
        html += `<p>Unsupported question type: ${qType}</p>`;
      }

      html += `</div></div>`;
      return html;
    }

    function shuffleArray(arr) {
      return arr
        .map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ value }) => value);
    }

    window.addEventListener('resize', () => { bubbleX = window.innerWidth / 2; bubbleY = window.innerHeight / 2; targetX = bubbleX; targetY = bubbleY; });

    console.log("Eye-bubble exam loaded. Run via localhost or allow camera access.");
  </script>
</body>

</html>