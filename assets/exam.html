<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Exam Portal â€” Full FaceMesh with Eye Bubble</title>

  <!-- Firebase + App Initialization FIRST -->
  <script type="module">
    window.isPageReload = performance.getEntriesByType("navigation")[0].type === "reload";
    console.log("Reload detected?", window.isPageReload);
    window.isReloadSession = false;
    window.skipIncompleteOnNextUnload = false;
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getFirestore, collection, getDocs, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    import { deleteField } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    // ====== Firebase Config from your FlutterFire options ======
    const firebaseConfig = {
      apiKey: 'AIzaSyD3QA26qrdwXjt1eRn_OBqX0zw8kbiyV3o',
      appId: '1:348602182315:web:e5b92040815a2ef94665ee',
      messagingSenderId: '348602182315',
      projectId: 'rd-final',
      authDomain: 'rd-final.firebaseapp.com',
      databaseURL: 'https://rd-final-default-rtdb.asia-southeast1.firebasedatabase.app',
      storageBucket: 'rd-final.firebasestorage.app',
      measurementId: 'G-WBN9RY3QKG'
    };
    window.firestoreDoc = doc;
    window.firestoreCollection = collection;

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    window.answers = {};
    window.db = db; // make db global so your exam code can access it
    window.strikes = window.strikes ?? 0;
    window.examFinished = window.examFinished ?? false;
    window.cheatingCount = window.cheatingCount ?? 0;
    window.logCheatingEvent = async function logCheatingEvent() {
      if (window.examFinished) return;
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(db, "examResults", examId, studentId, "result");
        const snap = await getDoc(resultRef);
        const currentStatus = snap.exists() ? snap.data().status : null;
        if (currentStatus === "completed" || currentStatus === "incomplete") return;

        await setDoc(resultRef, {
          examId,
          studentId,
          status: currentStatus ?? "in-progress",
          lastCheatingUpdate: new Date(),
          cheatingCount: (snap.exists() && snap.data().cheatingCount ? snap.data().cheatingCount + 1 : 1)
        }, { merge: true });

        window.cheatingCount++;
        console.log(`Cheating logged! Count: ${window.cheatingCount}`);
      } catch (err) {
        console.error("logCheatingEvent error:", err);
      }
    };
    async function markInProgress() {
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(window.db, "examResults", examId, studentId, "result");
        const snap = await getDoc(resultRef);

        if (snap.exists()) {
          const status = snap.data().status;
          if (status === "completed" || status === "incomplete") {
            // Already finished â€” redirect to result page
            window.parent.postMessage({
              action: 'finishExam',
              examId: examId,
              studentId: studentId
            }, "*");
            return;
          }
        }

        // Otherwise mark in-progress
        await setDoc(resultRef, {
          status: "in-progress",
          startedAt: new Date()
        }, { merge: true });

        console.log("Exam marked in-progress");
      } catch (err) {
        console.error("markInProgress error:", err);
      }
    }



    // Single canonical strike register
    window.registerStrikeOnce = (function () {
      let lastAway = 0;
      return function registerStrikeOnce() {
        const now = Date.now();
        if (now - lastAway < 1200) return;
        lastAway = now;
        window.strikes++;
        document.getElementById("strikeBox").textContent = `Strikes: ${window.strikes}`;
        window.logCheatingEvent();
        console.log("Strikes updated:", window.strikes);
        sendToArduino("STRIKE");////still being tested when connected to arduino
      };
    })();

    // Mark incomplete (keep this in module so beforeunload can call it safely)
    window.markIncompleteIfNeeded = function () {
      try {
        if (window.examFinished) return;
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) return;

        const resultRef = doc(window.db, "examResults", examId, studentId, "result");
        setDoc(resultRef, {
          status: "incomplete",
          submittedAt: new Date()
        }, { merge: true });

        console.log("Exam marked incomplete");
      } catch (err) {
        console.error("markIncomplete error:", err);
      }
    };


    window.saveAnswerToFirestore = async function (q, val, displayIndex) {
      const examId = window.examData?.examId;
      const studentId = window.examData?.studentId;
      if (!examId || !studentId) return;

      const studentCollection = collection(doc(window.db, "examResults", examId), studentId);
      const resultRef = doc(studentCollection, "result");
      const answerRef = doc(collection(resultRef, "answers"), q.id);

      let answerValue = val;
      if (q.type?.toLowerCase() === "checkbox") {
        // collect all checked boxes for this question
        const inputs = document.querySelectorAll(`input[name="${q.id}"]:checked`);
        answerValue = Array.from(inputs).map(i => i.value);
      }

      try {
        await setDoc(answerRef, {
          questionId: q.id,
          question: q.questionText,
          answer: answerValue,
          correctAnswer: q.correctAnswer,
          displayIndex
        }, { merge: true });
        window.answers[q.id] = answerValue;
        console.log("Answer saved:", answerValue);
      } catch (err) {
        console.error("Firestore save failed:", err);
      }
    };

    window.submitExam = async function submitExam() {
      try {
        const examId = window.examData?.examId;
        const studentId = window.examData?.studentId;
        if (!examId || !studentId) {
          console.error("Missing examId or studentId");
          return;
        }

        // 1) Fetch all saved answers from Firestore
        const studentCollection = collection(doc(window.db, "examResults", examId), studentId);
        const resultRef = doc(studentCollection, "result");
        const answersCol = collection(resultRef, "answers");
        const answersSnap = await getDocs(answersCol);

        const savedAnswers = {};
        answersSnap.forEach(docSnap => {
          const data = docSnap.data();
          savedAnswers[data.questionId] = data.answer;
        });

        // 2) Compute score using saved answers + correctAnswer from window.questions
        let computedScore = 0;
        for (let i = 0; i < window.questions.length; i++) {
          const q = window.questions[i];
          const ans = savedAnswers[q.id];   // use Firestore answers
          const correct = q.correctAnswer;

          if (ans && correct) {
            if (ans.toString().toLowerCase() === correct.toString().toLowerCase()) {
              computedScore++;
            }
          }
        }

        // 3) Get subject from exam doc
        let subject = "";
        try {
          const examDoc = await getDoc(doc(window.db, "exams", examId));
          if (examDoc.exists()) {
            subject = examDoc.data().subject || "";
          }
        } catch (err) {
          console.warn("Could not fetch subject:", err);
        }

        // Write result to Firestore
        await setDoc(resultRef, {
          status: "completed",
          score: computedScore,
          total: window.questions.length,
          subject,
          submittedAt: serverTimestamp()
        }, { merge: true });

        console.log(" Exam submitted. Score:", computedScore);

        // Redirect to result page
        window.parent.postMessage({
          action: 'finishExam',
          examId: examId,
          studentId: studentId
        }, "*");
        // Mark exam finished
        window.examFinished = true;
        window.questions = [];
        window.answers = {};
        window.examData = null;
        window.cheatingCount = 0;
        window.strikes = 0;
        sessionStorage.clear();
        // Stop camera if running
        try { camera?.stop?.(); } catch (_) { }
      } catch (err) {
        console.error(" submitExam error:", err.message, err);
      }
    };
    // inside <script type="module">
    async function startCountdownFromFirestore(examId) {
      console.log(" startCountdownFromFirestore called with examId:", examId);

      const examRef = doc(db, "exams", examId);   //  doc is available here
      const examSnap = await getDoc(examRef);

      if (!examSnap.exists()) {
        console.error(" Exam not found for examId:", examId);
        countdownEl.textContent = "Exam not found!";
        return;
      }

      const data = examSnap.data();
      console.log(" Exam data:", data);

      const endTime = data.endTime?.toDate?.().getTime?.();
      const startTime = data.startTime?.toDate?.().getTime?.();

      if (!endTime || !startTime) {
        console.error(" Missing start/end time in exam doc:", data);
        countdownEl.textContent = "No schedule set";
        return;
      }

      const timer = setInterval(() => {
        const durationMs = endTime - startTime;
        const elapsedMs = Date.now() - startTime;
        const remainingMs = Math.max(durationMs - elapsedMs, 0);
        if (remainingMs <= 0) {
          clearInterval(timer);
          countdownEl.textContent = "Time's up!";
          window.markIncompleteIfNeeded();
          window.parent.postMessage({
            action: 'finishExam',
            examId: examId,
            studentId: studentId
          }, "*");
          return;
        }
        countdownEl.textContent = "Time Left: " + formatRemaining(remainingMs);
      }, 1000);
      console.log(" Firestore db object:", window.db);
      console.log(" typeof doc:", typeof doc);
    }


    // Visibility change â†’ log strike if not reload/shell
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        setTimeout(() => {
          if (document.hidden && !window.skipIncompleteOnNextUnload) {
            window.registerStrikeOnce();
          }
        }, 1200); // throttle to avoid flicker
      }
    });
    //Detect window shrink on mobile + iframe + Flutter
    const MIN_WIDTH = 600;   // set your minimum safe exam size
    const MIN_HEIGHT = 450;

    // Observes the real viewport (fires even inside iframe/mobile)
    new ResizeObserver(() => {
      const vw = document.documentElement.clientWidth;
      const vh = document.documentElement.clientHeight;

      if ((vw < MIN_WIDTH || vh < MIN_HEIGHT) && !window.skipIncompleteOnNextUnload) {
        console.log("Viewport too small â€” strike");
        window.registerStrikeOnce();
      }
    }).observe(document.documentElement);

    // Extra layer: detect iframe/body being resized by Flutter shell
    new ResizeObserver(() => {
      const rect = document.body.getBoundingClientRect();

      if ((rect.width < MIN_WIDTH || rect.height < MIN_HEIGHT) && !window.skipIncompleteOnNextUnload) {
        console.log("Iframe/body shrink detected â€” strike");
        window.registerStrikeOnce();
      }
    }).observe(document.body);
    // Detect parent-shell losing visibility (app switch, minimize, home button, etc.)
    window.addEventListener("message", (event) => {
      if (!event.data) return;

      // if (event.data.action === "shell-blur") {
      //   if (!window.skipIncompleteOnNextUnload) {
      //     console.log("parent window blur (app switch/minimize) â€” strike");
      //     window.registerStrikeOnce();
      //   }
      // }

      if (event.data.action === "shell-focus") {
        console.log("Shell refocused");
      }
    });
    window.addEventListener("beforeunload", () => {

      sessionStorage.setItem("is_unloading", "true");

      if (window.examStarted) {
        sessionStorage.setItem("examStarted", "1");
      }

      if (window.isPageReload || window.skipIncompleteOnNextUnload) {
        console.log("Reload detected â†’ skip markIncomplete");
        return;
      }

      console.log("Tab close/back nav â†’ markIncomplete");
      window.markIncompleteIfNeeded();
    });

    //Pagehide: same logic
    // window.addEventListener("pagehide", (event) => {
    //   if (event.persisted || window.isReloadSession || window.skipIncompleteOnNextUnload) {
    //     console.log("Reload/back nav/shell detected, skip markIncomplete");
    //     return;
    //   }
    //   console.log("Reload/back nav pagehide");
    //   window.markIncompleteIfNeeded();
    // });

    // On load: check flag and set reload session
    window.addEventListener("DOMContentLoaded", async () => {
      const examId = window.examData?.examId;
      const studentId = window.examData?.studentId;

      const wasUnloading = sessionStorage.getItem("is_unloading");

      if (wasUnloading) {
        console.log("Page reloaded â†’ restoring session state");

        window.isReloadSession = true;

        sessionStorage.removeItem("is_unloading");

        if (examId && studentId) {
          const resultRef = doc(window.db, "examResults", examId, studentId, "result");
          await setDoc(resultRef, { status: "in-progress" }, { merge: true });
          console.log("Exam restored to in-progress");
          await loadExistingStrikes();
        } else {
          console.warn("Reload but examId/studentId were not ready yet");
        }
      } else {
        console.log("Fresh load or tab reopened");
        window.isReloadSession = false;
      }
      const wasStarted = sessionStorage.getItem("examStarted") === "1";

      if (wasStarted) {
        console.log("Restoring exam view after reload");

        window.examStarted = true;
        window.allowStrikes = true;

        document.getElementById("examGate").style.display = "none";
        document.getElementById("examCard").style.display = "block";

      } else {
        window.examStarted = false;
        window.allowStrikes = false;

        document.getElementById("examGate").style.display = "block";
        document.getElementById("examCard").style.display = "none";
      }

      setTimeout(() => {
        window.isReloadSession = false;
        console.log("Reload session cleared â†’ next unload is normal");
      }, 50);
    });
    // this is the replacement for pagehide
    // window.addEventListener("pagehide", () => {
    //   const examId = window.examData?.examId;
    //   const studentId = window.examData?.studentId;

    //   if (!examId || !studentId) return;

    //   const payload = JSON.stringify({ examId, studentId });
    //   const blob = new Blob([payload], { type: "application/json" });

    //   navigator.sendBeacon(
    //     "https://asia-southeast1-rd-final.cloudfunctions.net/markIncomplete",
    //     blob
    //   );

    //   console.log("Beacon sent: markIncomplete triggered");
    // });
    //==================this the node,js===========
    // exports.markIncomplete = functions.https.onRequest(async (req, res) => {
    //   try {
    //     // Only allow POST requests
    //     if (req.method !== "POST") {
    //       return res.status(405).send("Method Not Allowed");
    //     }

    //     // Enable CORS for all origins (or restrict to your domain)
    //     res.set("Access-Control-Allow-Origin", "*");
    //     res.set("Access-Control-Allow-Methods", "POST");
    //     res.set("Access-Control-Allow-Headers", "Content-Type");

    //     // Parse JSON body
    //     let body = req.body;
    //     if (typeof body === "string") body = JSON.parse(body);

    //     const { examId, studentId } = body;

    //     if (!examId || !studentId) {
    //       return res.status(400).json({ error: "Missing examId or studentId" });
    //     }

    //     // Reference to Firestore document: examResults/{examId}/{studentId}/result
    //     const resultRef = db
    //       .collection("examResults")
    //       .doc(examId)
    //       .collection(studentId)
    //       .doc("result");

    //     await resultRef.set(
    //       {
    //         status: "incomplete",
    //         submittedAt: admin.firestore.FieldValue.serverTimestamp(),
    //       },
    //       { merge: true }
    //     );

    //     console.log(`Exam ${examId} for student ${studentId} marked incomplete`);

    //     return res.status(200).json({ success: true });
    //   } catch (err) {
    //     console.error("markIncomplete error:", err);
    //     return res.status(500).json({ error: err.message });
    //   }
    // });



    // ===================== Load Questions from Firestore =====================
    // async function loadExamQuestions(examId) {
    //   if (!examId) return;
    //   window.questions = [];
    //   window.answers = {}; // start fresh
    //   currentQuestionIndex = 0;
    //   document.getElementById('examContent').innerHTML = `
    //     <h2>Loadingâ€¦</h2>
    //     <div class="question"><p>Fetching questionsâ€¦</p></div>
    //     `;

    //   try {
    //     const questionsCol = collection(db, "exams", examId, "questions");
    //     const snapshot = await getDocs(questionsCol);

    //     if (snapshot.empty) {
    //       document.getElementById('examContent').innerHTML = "<p>No questions found.</p>";
    //       return;
    //     }

    //     // Collect questions in order
    //     const rawQuestions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    //     questions = shuffleArray(rawQuestions).map((q, idx) => ({
    //       ...q,
    //       index: idx // embed shuffled index per student
    //     }));
    //     window.questions = questions;

    //     matchingPool = Array.from(new Set(
    //       questions
    //         .filter(q => q.type?.toLowerCase() === "matching" && Array.isArray(q.options))
    //         .flatMap(q => q.options)
    //     ));
    //     // strikes = 0;
    //     // strikeBox.textContent = `Strikes: ${strikes}`;
    //     // scoreBox.textContent = `Score: 0/${window.questions.length}`;
    //     setVerification(false, "Face not verified");

    //     // Generate HTML
    //     showQuestion(currentQuestionIndex);


    //     // Reset UI state
    //     // strikes = 0;
    //     // strikeBox.textContent = `Strikes: ${strikes}`;
    //     // blocked = false;
    //     // submitBtn.disabled = false;
    //     // submitBtn.textContent = "Submit Exam";
    //     // scoreBox.textContent = `Score: 0/${questions.length}`;
    //     setVerification(false, "Face not verified");


    //   } catch (err) {
    //     console.error("Failed to load exam questions:", err);
    //     document.getElementById('examContent').innerHTML = `<p>Error loading questions: ${err.message}</p>`;
    //   }
    // }
    let currentQuestionIndex = 0;
    function showQuestion(index) {
      const q = window.questions?.[index];
      if (!q) {
        console.warn("showQuestion invalid index:", index, "len:", window.questions?.length ?? 0);
        return;
      }

      try {
        document.getElementById('examContent').innerHTML =
          generateQuestionHtml(q, index, window.answers, window.matchingPool || []);
      } catch (err) {
        console.error("generateQuestionHtml failed:", err);
        document.getElementById('examContent').innerHTML = `
      <h2>Question ${index + 1}</h2>
      <div class="question"><p>${q.questionText ?? "No text"}</p></div>
    `;
      }

      renderNextOrSubmitButton();
    }
    function renderNextOrSubmitButton() {
      const btn = document.getElementById("nextQuestion");
      if (!btn) return;

      if (currentQuestionIndex < (window.questions?.length ?? 0) - 1) {
        btn.textContent = "Next";
        btn.onclick = async () => {
          currentQuestionIndex++;
          showQuestion(currentQuestionIndex);

          try {
            const examId = window.examData.examId;
            const studentId = window.examData.studentId;

            const studentCollection = collection(
              doc(window.db, "examResults", examId),
              studentId
            );

            const resultRef = doc(studentCollection, "result");

            await setDoc(resultRef, {
              currentIndex: currentQuestionIndex
            }, { merge: true });

            console.log("Saved currentIndex:", currentQuestionIndex);

          } catch (err) {
            console.error("Failed to save currentIndex:", err);
          }
        };
      } else {
        btn.textContent = "Submit";
        btn.onclick = () => window.submitExam();

      }
    }

    async function loadExamQuestions(examId) {
      if (!examId) {
        console.error("loadExamQuestions called with null examId");
        return;
      }

      // Reset UI placeholders
      document.getElementById('examContent').innerHTML = `
    <h2>Loadingâ€¦</h2>
    <div class="question"><p>Loadingâ€¦</p></div>
  `;

      try {
        console.log(" Fetching questions from Firestore for examId:", examId);

        // 1) Fetch all question docs
        const questionsCol = collection(db, "exams", examId, "questions");
        const snapshot = await getDocs(questionsCol);
        console.log("Snapshot size:", snapshot.size);

        if (snapshot.empty) {
          console.error("No questions found in Firestore for exam:", examId);
          document.getElementById('examContent').innerHTML = "<p>No questions found.</p>";
          return;
        }

        const rawQuestions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        console.log("Raw questions fetched:", rawQuestions.map(q => q.id));
        const groups = {
          "true-false": [],
          "multiple-choice": [],
          "matching": []
        };

        // Put each question into its group
        rawQuestions.forEach(q => {
          const t = (q.type || "").toLowerCase();
          if (groups[t]) groups[t].push(q);
        });

        // Shuffle each group independently
        Object.keys(groups).forEach(type => {
          groups[type] = shuffleArray(groups[type]);
        });

        // Build final grouped+random order
        const sortedRandom = [
          ...groups["true-false"],
          ...groups["multiple-choice"],
          ...groups["matching"]
        ];

        // This replaces the old rawQuestions order
        const finalQuestions = sortedRandom;

        // 2) Get saved order or shuffle and save once
        const resultRef = doc(db, "examResults", examId, window.examData.studentId, "result");
        const resultSnap = await getDoc(resultRef);

        let orderedIds;
        if (resultSnap.exists() && resultSnap.data().questionOrder) {
          orderedIds = resultSnap.data().questionOrder;
          console.log("Restored questionOrder from Firestore:", orderedIds);
        } else {
          orderedIds = finalQuestions.map(q => q.id);
          await setDoc(resultRef, { questionOrder: orderedIds }, { merge: true });
          console.log("Saved grouped+random questionOrder:", orderedIds);
        }

        // 3) Build orderedQuestions AFTER we have orderedIds
        const orderedQuestions = orderedIds.map((qid, idx) => {
          const q = rawQuestions.find(rq => rq.id === qid);
          if (!q) {
            console.warn("Question ID not found:", qid);
            return null;
          }
          return {
            ...q,
            index: idx,
            // normalize fields defensively
            questionText: q.questionText ?? q.text ?? "",
            type: (q.type ?? q.kind ?? "multiple-choice").toLowerCase(),
            options: Array.isArray(q.options) ? q.options : (Array.isArray(q.choices) ? q.choices : [])
          };
        }).filter(Boolean);

        window.questions = orderedQuestions;
        window.answers = window.answers || {};

        // 4) Build matching pool now that window.questions exists
        window.matchingPool = Array.from(new Set(
          window.questions
            .filter(q => q.type === 'matching' && Array.isArray(q.options))
            .flatMap(q => q.options)
        ));
        console.log("Ordered questions array built:", window.questions);
        console.log("Matching pool:", window.matchingPool);

        // 5) Restore current index if saved
        if (resultSnap.exists() && resultSnap.data().currentIndex !== undefined) {
          currentQuestionIndex = resultSnap.data().currentIndex;
          console.log("Restored currentIndex:", currentQuestionIndex);
        } else {
          console.log("â„¹No currentIndex saved, starting at 0");
        }

        // 6) Render first question safely
        try {
          showQuestion(currentQuestionIndex);
          renderNextOrSubmitButton();
          console.log("First question rendered at index:", currentQuestionIndex);
        } catch (err) {
          console.error("showQuestion/render failed:", err);
          document.getElementById('examContent').innerHTML = `<p>Error rendering question: ${err.message}</p>`;
        }

      } catch (err) {
        console.error("loadExamQuestions failed:", err);
        document.getElementById('examContent').innerHTML = `<p>Error loading questions: ${err.message}</p>`;
      }
    }

    async function loadExistingStrikes() {
      const examId = window.examData?.examId;
      const studentId = window.examData?.studentId;
      if (!examId || !studentId) return;

      const resultRef = doc(db, "examResults", examId, studentId, "result");
      const snap = await getDoc(resultRef);

      if (snap.exists()) {
        const saved = snap.data().cheatingCount ?? 0;
        window.strikes = saved;            // update global strike counter
        window.cheatingCount = saved;      // keep both in sync
        const strikeBox = document.getElementById("strikeBox");
        if (strikeBox) {
          strikeBox.textContent = `Strikes: ${saved}`;
        }
        document.getElementById("strikeBox").textContent =
          `Strikes: ${saved}`;
        console.log("Restored strikes:", saved);
      } else {
        console.log("No existing result doc. Starting at 0 strikes.");
      }
    }


    // ===================== Usage =====================
    let examId;
    let studentId;
    let answers = {};

    console.log(" Initial examId:", examId, "studentId:", studentId);

    // Prefer Flutter injection, fallback to URL
    examId = window.flutterExamData?.examId ?? examId;
    studentId = window.flutterExamData?.studentId ?? studentId;
    answers = {}; // reset answers for a new exam

    console.log(" After Flutter injection:", examId, studentId);

    if (!examId || !studentId) {
      const urlParams = new URLSearchParams(window.location.search);
      console.log(" window.location.search:", window.location.search);
      examId = urlParams.get('examId');
      studentId = urlParams.get('studentId');
      console.log(" Parsed examId from URL:", examId, "studentId:", studentId);
    }

    // Set examData ONCE
    window.examData = { examId, studentId, answers };
    await loadExistingStrikes();
    markInProgress();
    console.log(" window.examData set:", window.examData);

    if (examId && studentId) {
      document.getElementById('examContent').innerHTML = `
    <h2>Loadingâ€¦</h2>
    <div class="question"><p>Loadingâ€¦</p></div>
  `;
      console.log(" Calling loadExamQuestions with examId:", examId);
      loadExamQuestions(examId);

      console.log(" Starting countdown for examId:", examId);
      startCountdownFromFirestore(examId);
    } else {
      console.error(" Missing examId or studentId, cannot load exam.");
    }

    console.log(" Final examId:", examId, "Final studentId:", studentId);
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --navy: #0f2b45;
      --card: #0f3b61;
      --accent: #1e90ff;
      --bg: #0b1220;
      --ok: #2ecc71;
      --warn: #ff6b6b;
      --muted: #b7c7d6;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg, #061225 0%, #071728 100%);
      color: #e6f0f8;
      -webkit-font-smoothing: antialiased;
      position: relative;
      min-height: 100vh;
    }

    .topbar {
      height: 64px;
      background: var(--navy);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, .4);
    }

    .topbar .brand {
      font-weight: 700;
      letter-spacing: 0.6px
    }

    .topbar .timer {
      font-size: 14px;
      color: var(--muted)
    }

    .wrap {
      max-width: 1100px;
      margin: 28px auto;
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 20px;
      padding: 0 16px;
    }

    .card {
      background: #0b2a44;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .4);
      position: relative;
      overflow: visible;
    }

    #examGate,
    #examCard {
      min-height: 500px;
    }

    .card h2 {
      margin: 0 0 14px;
      font-size: 18px;
      color: #f3fbff
    }

    .question {
      background: #071a2b;
      border-radius: 8px;
      padding: 14px;
      color: #dbeefc;
      margin-bottom: 18px;
    }

    .options label {
      display: block;
      padding: 8px 12px;
      margin: 8px 0;
      border-radius: 6px;
      cursor: pointer;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.03);
    }

    .options input {
      margin-right: 10px
    }

    .btn {
      background: var(--accent);
      color: #06203a;
      border: none;
      padding: 10px 18px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(30, 144, 255, .16);
    }

    select {
      width: 100%;
      padding: 10px 12px;
      background: #071a2b;
      color: #e6f0f8;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 6px;
      font-size: 15px;
      margin-top: 8px;
      margin-bottom: 8px;
      appearance: none;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      transition: border-color 0.2s, background-color 0.2s;
    }

    select:focus {
      outline: none;
      border-color: #1e90ff;
      background: #0b2a44;
    }

    /* Dropdown options */
    select option {
      background: #071a2b;
      color: #e6f0f8;
    }


    .card::after {
      content: "";
      position: absolute;
      inset: 6px;
      border: 3px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      pointer-events: none;
      transition: border-color 0.18s, box-shadow 0.18s;
    }

    .card.alert::after {
      border-color: var(--warn);
      box-shadow: 0 0 30px rgba(255, 107, 107, 0.12);
    }

    .camera-panel {
      background: #071a2b;
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .45);
    }

    .cam-viewport {
      position: relative;
      width: 100%;
      aspect-ratio: 4/5;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }

    video#input_video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    canvas#overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      transform: scaleX(-1);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
    }

    .face-status {
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(0, 0, 0, 0.15);
      color: var(--muted);
    }

    .face-status.ok {
      background: rgba(46, 204, 113, 0.12);
      color: var(--ok);
      border: 1px solid rgba(46, 204, 113, 0.18)
    }

    .face-status.bad {
      background: rgba(255, 107, 107, 0.08);
      color: var(--warn);
      border: 1px solid rgba(255, 107, 107, 0.12)
    }

    .recording {
      font-size: 13px;
      color: var(--muted)
    }

    .verified-line {
      font-weight: 600;
      font-size: 15px
    }

    .gaze-bubble {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(30, 144, 255, 0.95);
      box-shadow: 0 6px 14px rgba(30, 144, 255, 0.2);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 9999;
      transition: box-shadow 0.12s;
    }

    .gaze-bubble.alert {
      background: rgba(255, 107, 107, 0.95);
      box-shadow: 0 8px 20px rgba(255, 107, 107, 0.25);
    }

    .strike-indicator {
      position: absolute;
      right: 14px;
      top: 14px;
      font-size: 13px;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.12);
      padding: 6px 8px;
      border-radius: 8px;
    }

    .score-box {
      margin-top: 12px;
      font-weight: 600;
      font-size: 15px;
      color: var(--accent);
    }

    @media (max-width:900px) {
      .wrap {
        grid-template-columns: 1fr;
      }

      .camera-panel {
        order: 2;
      }

      #examContent {
        min-height: 380px;
      }

    }
  </style>
</head>

<body>

  <div class="topbar">
    <div class="brand">EXAM PORTAL</div>
    <div class="timer" id="countdown">Time Left: 00:00</div>
    <button id="connectBtn" class="btn">ðŸ”Œ Connect Arduino</button>
  </div>


  <div class="wrap">

    <!-- shared strike indicator (single id) -->
    <div style="position:relative;">
      <div class="strike-indicator" id="strikeBox" style="position:absolute; right:14px; top:-8px; z-index:20;">
        Strikes: 0
      </div>

      <!-- GATE CARD (visible first) -->
      <div class="card" id="examGate">
        <div id="examContentGate">
          <h2 style="text-align:center;">Face verification required</h2>
          <p style="text-align:center;">Please look at the screen to start your exam.</p>

          <div style="display:flex; justify-content:center; margin-top:12px;">
            <img src="assets/image/fots_student.png" style="width:180px; border-radius:8px;">
          </div>
        </div>
      </div>

      <!-- EXAM CARD (hidden first) -->
      <div class="card" id="examCard" style="display:none;">
        <div id="examContent">
          <h2>Question 1</h2>
          <div class="question">
            <p>Loading questions...</p>
          </div>
        </div>

        <div style="margin-top:12px; text-align:right;">
          <button class="btn" id="nextQuestion">Next</button>
        </div>
      </div>
    </div>




    <!-- RIGHT SIDE â€” CAMERA PANEL (NOW SEPARATE) -->
    <div class="camera-panel">
      <div class="cam-viewport">
        <video id="input_video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="status-row">
        <div id="faceStatus" class="face-status bad">
          <span id="faceIcon">â›”</span>
          <div>
            <div class="verified-line" id="faceText">Face not verified</div>
            <div style="font-size:12px; color:var(--muted)">
              Please center your face in the box and keep eyes on the screen
            </div>
          </div>
        </div>

        <div style="text-align:right">
          <div class="recording" id="recLabel">Recording. Active</div>
        </div>
      </div>
    </div>

  </div>

  <!-- Gaze bubble must stay OUTSIDE wrap -->
  <div id="gazeBubble" class="gaze-bubble" style="left:50%; top:50%; display:block;"></div>


  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ========== ARDUINO SERIAL CONNECTION ==========
    let port;
    let writer;

    document.getElementById('connectBtn').addEventListener('click', async () => {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        const textEncoder = new TextEncoderStream();
        const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
        writer = textEncoder.writable.getWriter();
        alert("Connected to Arduino!");
      } catch (err) {
        alert("Connection failed: " + err);
      }
    });

    async function sendToArduino(message) {
      if (!writer) return;
      await writer.write(message + "\n");
      console.log("Sent to Arduino:", message);
    }
    // ===============================================


    // ========== EXISTING EXAM CODE (UNCHANGED) ==========
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('overlay');
    const canvasCtx = canvasElement.getContext('2d');
    const faceStatus = document.getElementById('faceStatus');
    const faceText = document.getElementById('faceText');
    const faceIcon = document.getElementById('faceIcon');
    const countdownEl = document.getElementById('countdown');
    const submitBtn = document.getElementById('submitBtn');
    const examCard = document.getElementById('examCard');
    const gazeBubble = document.getElementById('gazeBubble');
    const strikeBox = document.getElementById('strikeBox');

    let totalSeconds = 60 * 60;
    window.allowStrikes = false;

    function formatRemaining(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const hours = Math.floor(totalSec / 3600);
      const minutes = Math.floor((totalSec % 3600) / 60);
      const seconds = totalSec % 60;
      if (hours > 0) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.55,
      minTrackingConfidence: 0.55
    });

    let verified = false;
    let lastVerifiedChange = Date.now();
    const STABLE_MS = 300;
    let strikes = 0;
    let blocked = false;

    let bubbleX = window.innerWidth / 2, bubbleY = window.innerHeight / 2;
    let targetX = bubbleX, targetY = bubbleY;
    const SENSITIVITY = 10.4;

    function onResults(results) {
      const vw = videoElement.clientWidth;
      const vh = videoElement.clientHeight;
      canvasElement.width = vw; canvasElement.height = vh;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        setVerification(false, "Face not found");
        targetX = window.innerWidth / 2; targetY = window.innerHeight / 2;
        updateBubble(); return;
      }

      const lm = results.multiFaceLandmarks[0];
      const leftIris = lm[468];
      const rightIris = lm[473];
      const leftEyeFallback = lm[159];
      const rightEyeFallback = lm[386];

      let irisXNorm, irisYNorm;
      if (leftIris && rightIris) { irisXNorm = (leftIris.x + rightIris.x) / 2; irisYNorm = (leftIris.y + rightIris.y) / 2; }
      else if (leftIris) { irisXNorm = leftIris.x; irisYNorm = leftIris.y; }
      else if (rightIris) { irisXNorm = rightIris.x; irisYNorm = rightIris.y; }
      else { irisXNorm = (leftEyeFallback.x + rightEyeFallback.x) / 2; irisYNorm = (leftEyeFallback.y + rightEyeFallback.y) / 2; }

      const irisXVideo = (1 - irisXNorm) * vw;
      const irisYVideo = irisYNorm * vh;

      canvasCtx.beginPath();
      canvasCtx.fillStyle = 'rgba(30,144,255,0.95)';
      canvasCtx.arc(irisXVideo, irisYVideo, 5, 0, Math.PI * 2);
      canvasCtx.fill();

      const offsetX = (irisXVideo - vw / 2) / vw;
      const offsetY = (irisYVideo - vh / 2) / vh;

      // choose the element that is currently visible (gate or exam)
      const targetEl = (window.examStarted ? document.getElementById('examCard') : document.getElementById('examGate'));
      const examRect = targetEl.getBoundingClientRect();
      if (examRect.width < 20 || examRect.height < 20) {
        return; // skip frame to prevent freeze
      }
      const examCx = examRect.left + examRect.width / 2;
      const examCy = examRect.top + examRect.height / 2;

      targetX = examCx + offsetX * examRect.width * SENSITIVITY;
      targetY = examCy + offsetY * examRect.height * SENSITIVITY;

      const pad = 8;
      targetX = Math.max(pad, Math.min(window.innerWidth - pad, targetX));
      targetY = Math.max(pad, Math.min(window.innerHeight - pad, targetY));

      const INSET_PCT = 0.06;
      const safeLeft = examRect.left + examRect.width * INSET_PCT;
      const safeRight = examRect.right - examRect.width * INSET_PCT;
      const safeTop = examRect.top + examRect.height * INSET_PCT;
      const safeBottom = examRect.bottom - examRect.height * INSET_PCT;

      const gazeOk = (targetX >= safeLeft && targetX <= safeRight && targetY >= safeTop && targetY <= safeBottom);

      if (!gazeOk) {
        examCard.classList.add('alert');
        gazeBubble.classList.add('alert');
        setVerification(false, "Looking away detected");
        if (window.allowStrikes) {
          registerStrikeOnce();
          sendToArduino("STRIKE");
        }
      } else {
        examCard.classList.remove('alert');
        gazeBubble.classList.remove('alert');
        setVerification(true, "Face & eyes centered");
        if (window.allowStrikes) {
          sendToArduino("OK");
        }
      }
      updateBubble();
    }


    function setVerification(ok, reason) {
      const now = Date.now();
      if (ok !== verified && (now - lastVerifiedChange) < STABLE_MS) return;
      if (ok !== verified) {
        verified = ok; lastVerifiedChange = now;
        if (verified) {
          faceStatus.classList.remove('bad');
          faceStatus.classList.add('ok');
          faceIcon.textContent = 'âœ”';
        }
        else {
          faceStatus.classList.remove('ok');
          faceStatus.classList.add('bad');
          faceIcon.textContent = 'âš ';
        }
      }
      faceText.textContent = reason || (verified ? "Face verified" : "Face not verified");
      // --- FACE VERIFIED â†’ FIRST TIME ONLY ---
      if (verified && !window.examStarted) {

        window.examStarted = true;
        window.allowStrikes = true;
        sessionStorage.setItem("examStarted", "1");

        setTimeout(() => {
          document.getElementById("examGate").style.display = "none";
          document.getElementById("examCard").style.display = "block";

          loadExamQuestions(window.examData.examId);
          console.log("Face verified â†’ starting examâ€¦");
        }, 150);
        setTimeout(() => {
          strikeBox.textContent = `Strikes: ${window.strikes}`;
        }, 200);
      }
    }

    function updateBubble() {
      bubbleX += (targetX - bubbleX) * 0.18;
      bubbleY += (targetY - bubbleY) * 0.18;
      gazeBubble.style.left = `${bubbleX}px`;
      gazeBubble.style.top = `${bubbleY}px`;
    }

    function animLoop() { updateBubble(); requestAnimationFrame(animLoop); }
    animLoop();

    let camera = null;
    try {
      camera = new Camera(videoElement, { onFrame: async () => { await faceMesh.send({ image: videoElement }); }, width: 640, height: 800 });
      faceMesh.onResults(onResults);
      camera.start();
    } catch (err) {
      console.warn("Camera start failed:", err);
      faceText.textContent = "Camera unavailable â€” try localhost or allow camera access.";
      faceIcon.textContent = "âš ";
    }
    let matchingPool = [];
    let questions = [];

    function generateQuestionHtml(q, currentIndex, answers, matchingPool) {
      const selectedAnswer = answers?.[q.id] ?? null;
      const qType = (q.type || 'multiple-choice').toString().toLowerCase();

      let html = `
    <h2>Question ${currentIndex + 1}</h2>
    <div class="question">
      <p>${q.questionText ?? ""}</p>
      <div class="options" data-qid="${q.id}" data-qtype="${qType}">
  `;

      const save = (val) => `onchange="saveAnswerToFirestore(window.questions[${currentIndex}], this.value, ${currentIndex})"`;

      if (qType === 'multiple-choice') {
        (q.options ?? []).forEach(opt => {
          const checked = opt === selectedAnswer ? 'checked' : '';
          html += `
        <label>
          <input type="radio" name="${q.id}" value="${opt}" ${checked} ${save()}>
          ${opt}
        </label>`;
        });
      } else if (qType === 'true-false') {
        ['True', 'False'].forEach(opt => {
          const checked = opt === selectedAnswer ? 'checked' : '';
          html += `
        <label>
          <input type="radio" name="${q.id}" value="${opt}" ${checked} ${save()}>
          ${opt}
        </label>`;
        });
      } else if (qType === 'matching') {
        const pool = Array.isArray(matchingPool) ? matchingPool : [];
        html += `<select name="${q.id}" ${save()}>  
  <option value="" disabled selected>Select answer</option>
`;
        pool.forEach(m => {
          const selected = m === selectedAnswer ? 'selected' : '';
          html += `<option value="${m}" ${selected}>${m}</option>`;
        });
        html += `</select>`;
      } else if (qType === 'checkbox') {
        (q.options ?? []).forEach(opt => {
          const checked = Array.isArray(selectedAnswer) && selectedAnswer.includes(opt) ? 'checked' : '';
          // Note: saveAnswerToFirestore stores the last change; consider batching for full checkbox selection.
          html += `
        <label>
          <input type="checkbox" name="${q.id}" value="${opt}" ${checked}
            onchange="saveAnswerToFirestore(window.questions[${currentIndex}], this.checked ? '${opt}' : null, ${currentIndex})">
          ${opt}
        </label>`;
        });
      } else if (qType === 'text') {
        html += `
      <input type="text" name="${q.id}" value="${selectedAnswer ?? ''}"
        ${save()}>
    `;
      } else {
        html += `<p>Unsupported question type: ${qType}</p>`;
      }

      html += `</div></div>`;
      return html;
    }





    // After loading all questions
    //showQuestion(currentQuestionIndex);


    answers = collectAnswers();  // key = questionId / index, value = selected answer
    function renderQuestion(question) {
      const qEl = document.createElement('div');
      qEl.className = 'question';
      qEl.dataset.qid = question.id;

      const qText = document.createElement('p');
      qText.textContent = question.questionText;
      qEl.appendChild(qText);

      const optionsDiv = document.createElement('div');
      optionsDiv.className = 'options';

      switch (question.type) {
        case 'multiple-choice':
          question.options.forEach(opt => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="radio" name="${question.id}" value="${opt}"> ${opt}`;
            optionsDiv.appendChild(label);
          });
          break;
        case 'checkbox':
          question.options.forEach(opt => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" name="${question.id}" value="${opt}"> ${opt}`;
            optionsDiv.appendChild(label);
          });
          break;
        case 'text':
          const input = document.createElement('input');
          input.type = 'text';
          input.name = question.id;
          input.placeholder = 'Type your answer';
          optionsDiv.appendChild(input);
          break;
      }

      qEl.appendChild(optionsDiv);
      return qEl;
    }



    function collectAnswers() {
      const questionElements = document.querySelectorAll('.question');
      const answers = {};

      questionElements.forEach(qEl => {
        const qId = qEl.dataset.qid;
        const type = qEl.dataset.qtype;

        if (type === 'multiple-choice') {
          answers[qId] = qEl.querySelector('input[type="radio"]:checked')?.value || null;
        } else if (type === 'checkbox') {
          answers[qId] = Array.from(qEl.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
        } else if (type === 'text') {
          answers[qId] = qEl.querySelector('input[type="text"]').value || '';
        }
      });

      return answers;
    }

    function shuffleArray(arr) {
      return arr
        .map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ value }) => value);
    }


    // submitBtn.addEventListener('click', async () => {
    //   if (blocked || !verified) return alert('Cannot submit');

    //   const answers = collectAnswers();

    //   let score = 0;
    //   for (const qId in answers) {
    //     if (correctAnswers[qId] != null) {
    //       const ans = answers[qId];
    //       const correct = correctAnswers[qId];
    //       // For arrays (checkbox), compare sets
    //       if (Array.isArray(correct) && Array.isArray(ans)) {
    //         if (ans.sort().toString() === correct.sort().toString()) score++;
    //       } else if (ans === correct) score++;
    //     }
    //   }

    //   scoreBox.textContent = `Score: ${score}/${Object.keys(correctAnswers).length}`;

    //   const resultRef = doc(db, "examResults", examId, studentId, "result");
    //   await setDoc(resultRef, {
    //     studentId, examId, answers, score,
    //     submittedAt: new Date().toISOString(),
    //     status: "completed"
    //   }, { merge: true });

    //   alert(`Exam submitted! Score: ${score}/${Object.keys(correctAnswers).length}`);
    // });


    function loadExamFromFlutter(examHtml) {
      markInProgress();
      startCountdownFromFirestore(window.examData.examId);
      document.getElementById('examContent').innerHTML = examHtml;

      // Reset UI state
      // strikes = 0;
      // strikeBox.textContent = `Strikes: ${strikes}`;
      // blocked = false;
      // submitBtn.disabled = false;
      // submitBtn.textContent = "Submit Exam";
      // scoreBox.textContent = "Score: 0/1";
      setVerification(false, "Face not verified");
    }

    // On page load
    if (window.flutterExamData?.examHtml) {
      loadExamFromFlutter(window.flutterExamData.examHtml);
    }

    window.addEventListener('resize', () => { bubbleX = window.innerWidth / 2; bubbleY = window.innerHeight / 2; targetX = bubbleX; targetY = bubbleY; });

    console.log("Eye-bubble exam loaded. Run via localhost or allow camera access.");
    // ================================================================
  </script>
</body>

</html>